<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="es" http-equiv="Content-Language" />
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<link href="style.css" rel="stylesheet" type="text/css" />
<title>containers</title>
</head>
<body>
<h3>containers</h3>Monkey Containers Framework<br />The Containers framework supersedes the old Collections framework and allows cross-compatibility<br />with the official Monkey data structures (Stack, List, and Set).<br /><h3>Table of contents:</h3>Classes:<br><ul><li><a href='#375IComparableWrapper'>IComparableWrapper</a> <i>( Class IComparableWrapper  ) </i> </li><li><a href='#447PredicateEnumerator'>PredicateEnumerator</a> <i>( Class PredicateEnumerator&lt;T&gt; Implements IEnumerator&lt;T&gt; Abstract  ) </i> </li><li><a href='#516WrappedMapValueEnumerator'>WrappedMapValueEnumerator</a> <i>( Class WrappedMapValueEnumerator&lt;T&gt; Extends PredicateEnumerator&lt;T&gt;  ) </i> </li><li><a href='#547WrappedMapValueEnumerable'>WrappedMapValueEnumerable</a> <i>( Class WrappedMapValueEnumerable&lt;K,V&gt; Implements IEnumerable&lt;V&gt;  ) </i> </li><li><a href='#572WrappedStackEnumerator'>WrappedStackEnumerator</a> <i>( Class WrappedStackEnumerator&lt;T&gt; Extends PredicateEnumerator&lt;T&gt;  ) </i> </li><li><a href='#603WrappedStackEnumerable'>WrappedStackEnumerable</a> <i>( Class WrappedStackEnumerable&lt;T&gt; Implements IEnumerable&lt;T&gt;  ) </i> </li><li><a href='#628WrappedListEnumerator'>WrappedListEnumerator</a> <i>( Class WrappedListEnumerator&lt;T&gt; Extends PredicateEnumerator&lt;T&gt;  ) </i> </li><li><a href='#659WrappedListEnumerable'>WrappedListEnumerable</a> <i>( Class WrappedListEnumerable&lt;T&gt; Implements IEnumerable&lt;T&gt;  ) </i> </li><li><a href='#684WrappedSetEnumerator'>WrappedSetEnumerator</a> <i>( Class WrappedSetEnumerator&lt;T&gt; Extends PredicateEnumerator&lt;T&gt;  ) </i> </li><li><a href='#715WrappedSetEnumerable'>WrappedSetEnumerable</a> <i>( Class WrappedSetEnumerable&lt;T&gt; Implements IEnumerable&lt;T&gt;  ) </i> </li></ul>Interfaces:<br><ul><li><a href='#34IComparable'>IComparable</a> <i>( Interface IComparable  ) </i> </li><li><a href='#47IComparator'>IComparator</a> <i>( Interface IComparator&lt;T&gt;  ) </i> </li><li><a href='#59IEnumerator'>IEnumerator</a> <i>( Interface IEnumerator&lt;T&gt;  ) </i> </li><li><a href='#89IEnumerable'>IEnumerable</a> <i>( Interface IEnumerable&lt;T&gt;  ) </i> </li><li><a href='#99IPredicate'>IPredicate</a> <i>( Interface IPredicate&lt;T&gt;  ) </i> </li><li><a href='#106IPoolable'>IPoolable</a> <i>( Interface IPoolable  ) </i> </li><li><a href='#113IContainer'>IContainer</a> <i>( Interface IContainer&lt;T&gt;  ) </i> </li></ul><table style='width: 100%' id=34IComparable><tr id=IComparable><td class='tablehead' colspan='2'>Interface IComparable </td></tr><tr><td style='width:90px'>Description:</td><td>Indicates that an object of this class should be able to compare itself with another instance, primarily for sorting.</td></tr><tr><td style='width:90px'>Details:</td><td>IComparable can't be generic at this point, because it's likely the developer would want to declare a cyclic declaration.<br />Cyclic declarations are currently unsupported by Monkey.<br /></td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#40CompareTo'>CompareTo</a> <i>( Method CompareTo:Int(other:Object) ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=40CompareTo><td class='subtablehead' colspan='2' id=CompareTo>Method CompareTo:Int(other:Object)</td></tr><tr><td style='width:90px'>Description:</td><td>Compares this instance of the class with another instance.</td></tr><tr><td style='width:90px'>Returns:</td><td>Int</td></tr><tr><td style='width:90px'>Details:</td><td>Return 0 if the objects are equal, a negative value if the passed object is "less than" this object,<br />or a positive value if the passed object is "greater than" this object.<br /></td></tr></table></tr></td></table><br /><table style='width: 100%' id=47IComparator><tr id=IComparator><td class='tablehead' colspan='2'>Interface IComparator&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Indicates that this class is able to compare two instances of the generic type, T.</td></tr><tr><td style='width:90px'>Details:</td><td>The comparison contract is identical to that of IComparable, as if lhs.CompareTo(rhs)<br /></td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#53Compare'>Compare</a> <i>( Method Compare:Int(lhs:T, rhs:T) ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=53Compare><td class='subtablehead' colspan='2' id=Compare>Method Compare:Int(lhs:T, rhs:T)</td></tr><tr><td style='width:90px'>Description:</td><td>Compares two instances of the generic type, T.</td></tr><tr><td style='width:90px'>Returns:</td><td>Int</td></tr><tr><td style='width:90px'>Details:</td><td>Return 0 if the objects are equal, a negative value if rhs is "less than" lhs,<br />or a positive value if rhs is "greater than" lhs.<br /></td></tr></table></tr></td></table><br /><table style='width: 100%' id=113IContainer><tr id=IContainer><td class='tablehead' colspan='2'>Interface IContainer&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>A class that implements IContainer&lt;T&gt; must be able to interact with all of Stack, List, and Set.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#132AddAll'>AddAll</a> <i>( Method AddAll:Void(src:Stack&lt;T&gt;) ) </i> </li><li><a href='#138AddAll'>AddAll</a> <i>( Method AddAll:Void(src:List&lt;T&gt;) ) </i> </li><li><a href='#144AddAll'>AddAll</a> <i>( Method AddAll:Void(src:Set&lt;T&gt;) ) </i> </li><li><a href='#150AddContainer'>AddContainer</a> <i>( Method AddContainer:Void(src:IContainer&lt;T&gt;) ) </i> </li><li><a href='#230AddItem'>AddItem</a> <i>( Method AddItem:Void(val:T) ) </i> </li><li><a href='#259ClearAll'>ClearAll</a> <i>( Method ClearAll:Void() ) </i> </li><li><a href='#119Comparator'>Comparator</a> <i>( Method Comparator:IComparator&lt;T&gt;() Property ) </i> </li><li><a href='#126Comparator'>Comparator</a> <i>( Method Comparator:Void(comparator:IComparator&lt;T&gt;) Property ) </i> </li><li><a href='#358Compare'>Compare</a> <i>( Method Compare:Int(lhs:T, rhs:T) ) </i> </li><li><a href='#204ContainsAll'>ContainsAll</a> <i>( Method ContainsAll:Bool(src:Stack&lt;T&gt;) ) </i> </li><li><a href='#210ContainsAll'>ContainsAll</a> <i>( Method ContainsAll:Bool(src:List&lt;T&gt;) ) </i> </li><li><a href='#216ContainsAll'>ContainsAll</a> <i>( Method ContainsAll:Bool(src:Set&lt;T&gt;) ) </i> </li><li><a href='#222ContainsContainer'>ContainsContainer</a> <i>( Method ContainsContainer:Bool(src:IContainer&lt;T&gt;) ) </i> </li><li><a href='#265ContainsItem'>ContainsItem</a> <i>( Method ContainsItem:Bool(val:T) ) </i> </li><li><a href='#333Count'>Count</a> <i>( Method Count:Int() ) </i> </li><li><a href='#254DeleteItem'>DeleteItem</a> <i>( Method DeleteItem:T(index:Int) ) </i> </li><li><a href='#364Equals'>Equals</a> <i>( Method Equals:Bool(lhs:T, rhs:T) ) </i> </li><li><a href='#349FillArray'>FillArray</a> <i>( Method FillArray:Int(arr:T[]) ) </i> </li><li><a href='#288FindItem'>FindItem</a> <i>( Method FindItem:Int(value:T) ) </i> </li><li><a href='#272GetItem'>GetItem</a> <i>( Method GetItem:T(index:Int) ) </i> </li><li><a href='#246InsertItem'>InsertItem</a> <i>( Method InsertItem:Void(index:Int, val:T) ) </i> </li><li><a href='#369IsEmpty'>IsEmpty</a> <i>( Method IsEmpty:Bool() ) </i> </li><li><a href='#311Items'>Items</a> <i>( Method Items:IEnumerable&lt;T&gt;(pred:IPredicate&lt;T&gt;=Null) ) </i> </li><li><a href='#156RemoveAll'>RemoveAll</a> <i>( Method RemoveAll:Void(src:Stack&lt;T&gt;) ) </i> </li><li><a href='#162RemoveAll'>RemoveAll</a> <i>( Method RemoveAll:Void(src:List&lt;T&gt;) ) </i> </li><li><a href='#168RemoveAll'>RemoveAll</a> <i>( Method RemoveAll:Void(src:Set&lt;T&gt;) ) </i> </li><li><a href='#174RemoveContainer'>RemoveContainer</a> <i>( Method RemoveContainer:Void(src:IContainer&lt;T&gt;) ) </i> </li><li><a href='#237RemoveItem'>RemoveItem</a> <i>( Method RemoveItem:Void(val:T) ) </i> </li><li><a href='#180RetainAll'>RetainAll</a> <i>( Method RetainAll:Void(src:Stack&lt;T&gt;) ) </i> </li><li><a href='#186RetainAll'>RetainAll</a> <i>( Method RetainAll:Void(src:List&lt;T&gt;) ) </i> </li><li><a href='#192RetainAll'>RetainAll</a> <i>( Method RetainAll:Void(src:Set&lt;T&gt;) ) </i> </li><li><a href='#198RetainContainer'>RetainContainer</a> <i>( Method RetainContainer:Void(src:IContainer&lt;T&gt;) ) </i> </li><li><a href='#300Reverse'>Reverse</a> <i>( Method Reverse:Void() ) </i> </li><li><a href='#280SetItem'>SetItem</a> <i>( Method SetItem:Void(index:Int, value:T) ) </i> </li><li><a href='#306Shuffle'>Shuffle</a> <i>( Method Shuffle:Void() ) </i> </li><li><a href='#294SortItems'>SortItems</a> <i>( Method SortItems:Void(ascending:Bool = True) ) </i> </li><li><a href='#318SwapItems'>SwapItems</a> <i>( Method SwapItems:Void(index1:Int, index2:Int) ) </i> </li><li><a href='#340ToArray'>ToArray</a> <i>( Method ToArray:T[]() ) </i> </li><li><a href='#328Truncate'>Truncate</a> <i>( Method Truncate:Void(size:Int) ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=132AddAll><td class='subtablehead' colspan='2' id=AddAll>Method AddAll:Void(src:Stack&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Adds the entire contents of the passed Stack to the container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>AddAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=138AddAll><td class='subtablehead' colspan='2' id=AddAll>Method AddAll:Void(src:List&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Adds the entire contents of the passed List to the container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>AddAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=144AddAll><td class='subtablehead' colspan='2' id=AddAll>Method AddAll:Void(src:Set&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Adds the entire contents of the passed Set to the container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>AddAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=150AddContainer><td class='subtablehead' colspan='2' id=AddContainer>Method AddContainer:Void(src:IContainer&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Adds the entire contents of another container to this container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>AddContainer should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=230AddItem><td class='subtablehead' colspan='2' id=AddItem>Method AddItem:Void(val:T)</td></tr><tr><td style='width:90px'>Description:</td><td>Adds the passed item to the container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>No error should be thrown if the item already exists since Lists and Stacks allow duplicates.<br />Sets should do nothing if the item already exists.<br />A passed value of Null is implementation-dependent.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=259ClearAll><td class='subtablehead' colspan='2' id=ClearAll>Method ClearAll:Void()</td></tr><tr><td style='width:90px'>Description:</td><td>Removes all items from the container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=119Comparator><td class='subtablehead' colspan='2' id=Comparator>Method Comparator:IComparator&lt;T&gt;() Property</td></tr><tr><td style='width:90px'>Description:</td><td>Getter for the current sorting comparator.</td></tr><tr><td style='width:90px'>Returns:</td><td>IComparator</td></tr><tr><td style='width:90px'>Details:</td><td>Allows sorting without implementing IComparable.<br />Unsupported in Set.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=126Comparator><td class='subtablehead' colspan='2' id=Comparator>Method Comparator:Void(comparator:IComparator&lt;T&gt;) Property</td></tr><tr><td style='width:90px'>Description:</td><td>Setter for the current sorting comparator.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>Allows sorting without implementing IComparable.<br />Unsupported in Set.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=358Compare><td class='subtablehead' colspan='2' id=Compare>Method Compare:Int(lhs:T, rhs:T)</td></tr><tr><td style='width:90px'>Description:</td><td>Compares two instances of the generic type, T.</td></tr><tr><td style='width:90px'>Returns:</td><td>Int</td></tr><tr><td style='width:90px'>Details:</td><td>Return 0 if the objects are equal, a negative value if rhs is "less than" lhs,<br />or a positive value if rhs is "greater than" lhs.<br />A Null value should always be considered "less than" a non-Null value.<br />Sets are unordered and cannot be sorted, so they should throw an UnsupportedOperationException.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=204ContainsAll><td class='subtablehead' colspan='2' id=ContainsAll>Method ContainsAll:Bool(src:Stack&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns True if this container contains ALL of the elements in the passed Stack.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr><tr><td style='width:90px'>Details:</td><td>ContainsAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=210ContainsAll><td class='subtablehead' colspan='2' id=ContainsAll>Method ContainsAll:Bool(src:List&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns True if this container contains ALL of the elements in the passed List.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr><tr><td style='width:90px'>Details:</td><td>ContainsAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=216ContainsAll><td class='subtablehead' colspan='2' id=ContainsAll>Method ContainsAll:Bool(src:Set&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns True if this container contains ALL of the elements in the passed Set.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr><tr><td style='width:90px'>Details:</td><td>ContainsAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=222ContainsContainer><td class='subtablehead' colspan='2' id=ContainsContainer>Method ContainsContainer:Bool(src:IContainer&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns True if this container contains ALL of the elements in the passed container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr><tr><td style='width:90px'>Details:</td><td>ContainsContainer should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=265ContainsItem><td class='subtablehead' colspan='2' id=ContainsItem>Method ContainsItem:Bool(val:T)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns True if the container contains the passed value.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr><tr><td style='width:90px'>Details:</td><td>A passed value of Null is implementation-dependent.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=333Count><td class='subtablehead' colspan='2' id=Count>Method Count:Int()</td></tr><tr><td style='width:90px'>Description:</td><td>Returns the number of items in the container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Int</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=254DeleteItem><td class='subtablehead' colspan='2' id=DeleteItem>Method DeleteItem:T(index:Int)</td></tr><tr><td style='width:90px'>Description:</td><td>Deletes the item from the container at the requested index.</td></tr><tr><td style='width:90px'>Returns:</td><td>T</td></tr><tr><td style='width:90px'>Details:</td><td>No error should be thrown if the item already exists since Lists and Stacks allow duplicates.<br />Sets are unordered and should throw an UnsupportedOperationException.<br />If building with debug, an IllegalArgumentException should be thrown if the index is outside the range 0 &lt;= index &lt; Count()<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=364Equals><td class='subtablehead' colspan='2' id=Equals>Method Equals:Bool(lhs:T, rhs:T)</td></tr><tr><td style='width:90px'>Description:</td><td>Performs an equality test of lhs and rhs.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr><tr><td style='width:90px'>Details:</td><td>Returns True if they are logically equal, otherwise False.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=349FillArray><td class='subtablehead' colspan='2' id=FillArray>Method FillArray:Int(arr:T[])</td></tr><tr><td style='width:90px'>Description:</td><td>Fills the passed array with the items in the container, if there is space.</td></tr><tr><td style='width:90px'>Returns:</td><td>Int</td></tr><tr><td style='width:90px'>Details:</td><td>If the array length is &lt; Count(), an IllegalArgumentException should be thrown.<br />The first Count() items will contain the elements of the container, and any elements after that should be set to Null.<br />The method returns the number of elements actually filled.<br />Sets are unordered, therefore the order of the elements in the array will be undefined.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=288FindItem><td class='subtablehead' colspan='2' id=FindItem>Method FindItem:Int(value:T)</td></tr><tr><td style='width:90px'>Description:</td><td>Finds the first reference to the passed item and returns the index.</td></tr><tr><td style='width:90px'>Returns:</td><td>Int</td></tr><tr><td style='width:90px'>Details:</td><td>A value of -1 should be returned if the item is not found.<br />A passed value of Null is implementation-dependent.<br />Sets are unordered and should throw an UnsupportedOperationException.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=272GetItem><td class='subtablehead' colspan='2' id=GetItem>Method GetItem:T(index:Int)</td></tr><tr><td style='width:90px'>Description:</td><td>Gets the item at the given index.</td></tr><tr><td style='width:90px'>Returns:</td><td>T</td></tr><tr><td style='width:90px'>Details:</td><td>Sets are unordered and should throw an UnsupportedOperationException.<br />If building with debug, an IllegalArgumentException should be thrown if the index is outside the range 0 &lt;= index &lt; Count()<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=246InsertItem><td class='subtablehead' colspan='2' id=InsertItem>Method InsertItem:Void(index:Int, val:T)</td></tr><tr><td style='width:90px'>Description:</td><td>Adds the passed item to the container at the requested index.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>No error should be thrown if the item already exists since Lists and Stacks allow duplicates.<br />Sets are unordered and should throw an UnsupportedOperationException.<br />A passed value of Null is implementation-dependent.<br />If building with debug, an IllegalArgumentException should be thrown if the index is outside the range 0 &lt;= index &lt;= Count()<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=369IsEmpty><td class='subtablehead' colspan='2' id=IsEmpty>Method IsEmpty:Bool()</td></tr><tr><td style='width:90px'>Description:</td><td>Returns True if there are no elements in the container, otherwise False.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=311Items><td class='subtablehead' colspan='2' id=Items>Method Items:IEnumerable&lt;T&gt;(pred:IPredicate&lt;T&gt;=Null)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns a custom IEnumerable that optionally supports a predicate.</td></tr><tr><td style='width:90px'>Returns:</td><td>IEnumerable</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=156RemoveAll><td class='subtablehead' colspan='2' id=RemoveAll>Method RemoveAll:Void(src:Stack&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Removes from this container any objects that also appear in the passed Stack.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>RemoveAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=162RemoveAll><td class='subtablehead' colspan='2' id=RemoveAll>Method RemoveAll:Void(src:List&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Removes from this container any objects that also appear in the passed List.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>RemoveAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=168RemoveAll><td class='subtablehead' colspan='2' id=RemoveAll>Method RemoveAll:Void(src:Set&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Removes from this container any objects that also appear in the passed Set.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>RemoveAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=174RemoveContainer><td class='subtablehead' colspan='2' id=RemoveContainer>Method RemoveContainer:Void(src:IContainer&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Removes from this container any objects that also appear in the passed container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>RemoveContainer should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=237RemoveItem><td class='subtablehead' colspan='2' id=RemoveItem>Method RemoveItem:Void(val:T)</td></tr><tr><td style='width:90px'>Description:</td><td>Removes the passed item from the container, if it exists.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>No error should be thrown if the item does not exist.<br />A passed value of Null is implementation-dependent.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=180RetainAll><td class='subtablehead' colspan='2' id=RetainAll>Method RetainAll:Void(src:Stack&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Removes from this container any objects that DON'T appear in the passed Stack.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>RetainAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=186RetainAll><td class='subtablehead' colspan='2' id=RetainAll>Method RetainAll:Void(src:List&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Removes from this container any objects that DON'T appear in the passed List.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>RetainAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=192RetainAll><td class='subtablehead' colspan='2' id=RetainAll>Method RetainAll:Void(src:Set&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Removes from this container any objects that DON'T appear in the passed Set.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>RetainAll should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=198RetainContainer><td class='subtablehead' colspan='2' id=RetainContainer>Method RetainContainer:Void(src:IContainer&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Removes from this container any objects that DON'T appear in the passed container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>RetainContainer should throw an IllegalArgumentException if src is Null.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=300Reverse><td class='subtablehead' colspan='2' id=Reverse>Method Reverse:Void()</td></tr><tr><td style='width:90px'>Description:</td><td>Reverses the order of elements in the container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>Sets are unordered and should throw an UnsupportedOperationException.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=280SetItem><td class='subtablehead' colspan='2' id=SetItem>Method SetItem:Void(index:Int, value:T)</td></tr><tr><td style='width:90px'>Description:</td><td>Sets the item at a given index to be the passed value.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>A passed value of Null is implementation-dependent.<br />Sets are unordered and should throw an UnsupportedOperationException.<br />If building with debug, an IllegalArgumentException should be thrown if the index is outside the range 0 &lt;= index &lt; Count()<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=306Shuffle><td class='subtablehead' colspan='2' id=Shuffle>Method Shuffle:Void()</td></tr><tr><td style='width:90px'>Description:</td><td>Randomises the order of elements in the container.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>Sets are unordered and should throw an UnsupportedOperationException.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=294SortItems><td class='subtablehead' colspan='2' id=SortItems>Method SortItems:Void(ascending:Bool = True)</td></tr><tr><td style='width:90px'>Description:</td><td>Sorts the items based on the current Comparator or T's implementation of IComparable.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>Sets are unordered and should throw an UnsupportedOperationException.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=318SwapItems><td class='subtablehead' colspan='2' id=SwapItems>Method SwapItems:Void(index1:Int, index2:Int)</td></tr><tr><td style='width:90px'>Description:</td><td>Swaps the values of two given indices.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>Sets are unordered and should throw an UnsupportedOperationException.<br />If building with debug, an IllegalArgumentException should be thrown if either index is outside the range 0 &lt;= index &lt; Count()<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=340ToArray><td class='subtablehead' colspan='2' id=ToArray>Method ToArray:T[]()</td></tr><tr><td style='width:90px'>Description:</td><td>Returns a new array containing all the items in the container.</td></tr><tr><td style='width:90px'>Returns:</td><td>T</td></tr><tr><td style='width:90px'>Details:</td><td>The array length will be equal to Count().<br />Sets are unordered, therefore the order of the elements in the array will be undefined.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=328Truncate><td class='subtablehead' colspan='2' id=Truncate>Method Truncate:Void(size:Int)</td></tr><tr><td style='width:90px'>Description:</td><td>Reduces the number of items in the container to be no more than the passed size.</td></tr><tr><td style='width:90px'>Returns:</td><td>Void</td></tr><tr><td style='width:90px'>Details:</td><td>If there are less or equal elements in the container than the passed size, nothing happens.<br />If there are more elements in the container than the passed size, elements should be removed from the end<br />until Count() = the requested size.<br />Sets are unordered and should throw an UnsupportedOperationException.<br />If building with debug, an IllegalArgumentException should be thrown if the requested size &lt; 0.<br /></td></tr></table></tr></td></table><br /><table style='width: 100%' id=89IEnumerable><tr id=IEnumerable><td class='tablehead' colspan='2'>Interface IEnumerable&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Indicates that the class can be used in an EachIn loop.</td></tr><tr><td style='width:90px'>Details:</td><td>When the Monkey compiler reaches an EachIn statement such as:<br /><pre>For Local val := EachIn lst<br />	' your code<br />Next<br /></pre><br />It will internally convert it to:<br /><pre>Local oe:=lst.ObjectEnumerator()<br />While oe.HasNext()<br />	Local val:=oe.NextObject()<br />	' your code<br />End<br /></pre><br /></td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#93ObjectEnumerator'>ObjectEnumerator</a> <i>( Method ObjectEnumerator:IEnumerator&lt;T&gt;() ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=93ObjectEnumerator><td class='subtablehead' colspan='2' id=ObjectEnumerator>Method ObjectEnumerator:IEnumerator&lt;T&gt;()</td></tr><tr><td style='width:90px'>Description:</td><td>Returns an instance of IEnumerator that the EachIn operator can loop with.</td></tr><tr><td style='width:90px'>Returns:</td><td>IEnumerator</td></tr></table></tr></td></table><br /><table style='width: 100%' id=59IEnumerator><tr id=IEnumerator><td class='tablehead' colspan='2'>Interface IEnumerator&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Provides the HasNext() and NextObject() methods that the EachIn operator expects.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#64HasNext'>HasNext</a> <i>( Method HasNext:Bool() ) </i> </li><li><a href='#69NextObject'>NextObject</a> <i>( Method NextObject:T() ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=64HasNext><td class='subtablehead' colspan='2' id=HasNext>Method HasNext:Bool()</td></tr><tr><td style='width:90px'>Description:</td><td>Called once every EachIn loop to check if there are more objects available.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr><tr><td style='width:90px'>Details:</td><td>Returns False if the next call to NextObject() will fail.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=69NextObject><td class='subtablehead' colspan='2' id=NextObject>Method NextObject:T()</td></tr><tr><td style='width:90px'>Description:</td><td>Called once every EachIn loop to retrieve the next available object.</td></tr><tr><td style='width:90px'>Returns:</td><td>T</td></tr></table></tr></td></table><br /><table style='width: 100%' id=106IPoolable><tr id=IPoolable><td class='tablehead' colspan='2'>Interface IPoolable </td></tr><tr><td style='width:90px'>Description:</td><td>If a class implements IPoolable, Reset() will be called when it is freed within a DiddyPool or GlobalPool.</td></tr><tr><td style='width:90px'>Table of contents:</td><td></td></tr></table><br /><table style='width: 100%' id=99IPredicate><tr id=IPredicate><td class='tablehead' colspan='2'>Interface IPredicate&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>A class that implements IPredicate should act as a pseudo-lambda for predicate operations on the Container classes.</td></tr><tr><td style='width:90px'>Table of contents:</td><td></td></tr></table><br /><table style='width: 100%' id=375IComparableWrapper><tr id=IComparableWrapper><td class='tablehead' colspan='2'>Class IComparableWrapper </td></tr><tr><td style='width:90px'>Description:</td><td>IComparableWrapper is essentially a hack to get around Monkey's inability to cast primitives to objects.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Functions:<br><ul><li><a href='#410Compare'>Compare</a> <i>( Function Compare:Int(lhs:Object, rhs:Object) ) </i> </li><li><a href='#425Compare'>Compare</a> <i>( Function Compare:Int(lhs:Int, rhs:Int) ) </i> </li><li><a href='#432Compare'>Compare</a> <i>( Function Compare:Int(lhs:Float, rhs:Float) ) </i> </li><li><a href='#439Compare'>Compare</a> <i>( Function Compare:Int(lhs:String, rhs:String) ) </i> </li><li><a href='#379IsComparable'>IsComparable</a> <i>( Function IsComparable:Bool(src:Object) ) </i> </li><li><a href='#386IsComparable'>IsComparable</a> <i>( Function IsComparable:Bool(src:Int) ) </i> </li><li><a href='#393IsComparable'>IsComparable</a> <i>( Function IsComparable:Bool(src:Float) ) </i> </li><li><a href='#400IsComparable'>IsComparable</a> <i>( Function IsComparable:Bool(src:String) ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=410Compare><td class='subtablehead' colspan='2' id=Compare>Function Compare:Int(lhs:Object, rhs:Object)</td></tr><tr><td style='width:90px'>Description:</td><td>Performs a comparison on the passed objects.</td></tr><tr><td style='width:90px'>Returns:</td><td>Int</td></tr><tr><td style='width:90px'>Details:</td><td>If both objects are Null, returns 0.<br />If either object does not implement IComparable, returns 0.<br />Otherwise, IComparable.CompareTo() is called.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=425Compare><td class='subtablehead' colspan='2' id=Compare>Function Compare:Int(lhs:Int, rhs:Int)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns 0, because an Int can never implement an interface.</td></tr><tr><td style='width:90px'>Returns:</td><td>Int</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=432Compare><td class='subtablehead' colspan='2' id=Compare>Function Compare:Int(lhs:Float, rhs:Float)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns 0, because a Float can never implement an interface.</td></tr><tr><td style='width:90px'>Returns:</td><td>Int</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=439Compare><td class='subtablehead' colspan='2' id=Compare>Function Compare:Int(lhs:String, rhs:String)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns 0, because a String can never implement an interface.</td></tr><tr><td style='width:90px'>Returns:</td><td>Int</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=379IsComparable><td class='subtablehead' colspan='2' id=IsComparable>Function IsComparable:Bool(src:Object)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns True if the passed object implements the IComparable interface.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=386IsComparable><td class='subtablehead' colspan='2' id=IsComparable>Function IsComparable:Bool(src:Int)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns False, because an Int can never implement an interface.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=393IsComparable><td class='subtablehead' colspan='2' id=IsComparable>Function IsComparable:Bool(src:Float)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns False, because a Float can never implement an interface.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=400IsComparable><td class='subtablehead' colspan='2' id=IsComparable>Function IsComparable:Bool(src:String)</td></tr><tr><td style='width:90px'>Description:</td><td>Returns False, because a String can never implement an interface.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr></table></tr></td></table><br /><table style='width: 100%' id=447PredicateEnumerator><tr id=PredicateEnumerator><td class='tablehead' colspan='2'>Class PredicateEnumerator&lt;T&gt; Implements IEnumerator&lt;T&gt; Abstract </td></tr><tr><td style='width:90px'>Description:</td><td>Abstract class to provide predicate support to subclassed enumerators.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#505CallHasNext'>CallHasNext</a> <i>( Method CallHasNext:Bool() Abstract ) </i> </li><li><a href='#510CallNextObject'>CallNextObject</a> <i>( Method CallNextObject:T() Abstract ) </i> </li><li><a href='#470HasNext'>HasNext</a> <i>( Method HasNext:Bool() ) </i> </li><li><a href='#461New'>New</a> <i>( Method New(pred:IPredicate&lt;T&gt;=Null) ) </i> </li><li><a href='#492NextObject'>NextObject</a> <i>( Method NextObject:T() ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=505CallHasNext><td class='subtablehead' colspan='2' id=CallHasNext>Method CallHasNext:Bool() Abstract</td></tr><tr><td style='width:90px'>Description:</td><td>Abstract method that should delegate to the child enumerator's HasNext() method.</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=510CallNextObject><td class='subtablehead' colspan='2' id=CallNextObject>Method CallNextObject:T() Abstract</td></tr><tr><td style='width:90px'>Description:</td><td>Abstract method that should delegate to the child enumerator's NextObject() method.</td></tr><tr><td style='width:90px'>Returns:</td><td>T</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=470HasNext><td class='subtablehead' colspan='2' id=HasNext>Method HasNext:Bool()</td></tr><tr><td style='width:90px'>Description:</td><td>Implements IEnumerator<T>.HasNext().</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr><tr><td style='width:90px'>Details:</td><td>If no predicate is assigned, it immediately delegates to CallHasNext()<br />If there is a predicate, it delegates to CallHasNext() and CallNextObject() as required.<br /></td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=461New><td class='subtablehead' colspan='2' id=New>Method New(pred:IPredicate&lt;T&gt;=Null)</td></tr><tr><td style='width:90px'>Description:</td><td>Constructor with an optional predicate.</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=492NextObject><td class='subtablehead' colspan='2' id=NextObject>Method NextObject:T()</td></tr><tr><td style='width:90px'>Description:</td><td>Implements IEnumerator<T>.NextObject().</td></tr><tr><td style='width:90px'>Returns:</td><td>T</td></tr><tr><td style='width:90px'>Details:</td><td>If no predicate is assigned, it immediately delegates to CallNextObject()<br />If there is a predicate, it delegates to HasNext() and CallNextObject() as required.<br /></td></tr></table></tr></td></table><br /><table style='width: 100%' id=659WrappedListEnumerable><tr id=WrappedListEnumerable><td class='tablehead' colspan='2'>Class WrappedListEnumerable&lt;T&gt; Implements IEnumerable&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Wraps List and the ObjectEnumerator() method to provide access to a PredicateEnumerator&lt;T&gt;.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#668New'>New</a> <i>( Method New(l:List&lt;T&gt;, pred:IPredicate&lt;T&gt;=Null) ) </i> </li><li><a href='#676ObjectEnumerator'>ObjectEnumerator</a> <i>( Method ObjectEnumerator:IEnumerator&lt;T&gt;() ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=668New><td class='subtablehead' colspan='2' id=New>Method New(l:List&lt;T&gt;, pred:IPredicate&lt;T&gt;=Null)</td></tr><tr><td style='width:90px'>Description:</td><td>Constructor to wrap a List<T> enumerator as an IEnumerable<T> with an optional IPredicate<T>.</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=676ObjectEnumerator><td class='subtablehead' colspan='2' id=ObjectEnumerator>Method ObjectEnumerator:IEnumerator&lt;T&gt;()</td></tr><tr><td style='width:90px'>Description:</td><td>Returns a WrappedListEnumerator with the optional predicate.</td></tr><tr><td style='width:90px'>Returns:</td><td>IEnumerator</td></tr></table></tr></td></table><br /><table style='width: 100%' id=628WrappedListEnumerator><tr id=WrappedListEnumerator><td class='tablehead' colspan='2'>Class WrappedListEnumerator&lt;T&gt; Extends PredicateEnumerator&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Extends PredicateEnumerator&lt;T&gt; to wrap ListEnumerator&lt;T&gt; as an IEnumerator&lt;T&gt;.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#651CallHasNext'>CallHasNext</a> <i>( Method CallHasNext:Bool() ) </i> </li><li><a href='#644CallNextObject'>CallNextObject</a> <i>( Method CallNextObject:T() ) </i> </li><li><a href='#636New'>New</a> <i>( Method New(en:ListEnumerator&lt;T&gt;, pred:IPredicate&lt;T&gt;=Null) ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=651CallHasNext><td class='subtablehead' colspan='2' id=CallHasNext>Method CallHasNext:Bool()</td></tr><tr><td style='width:90px'>Description:</td><td>Delegates to ListEnumerator.HasNext().</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=644CallNextObject><td class='subtablehead' colspan='2' id=CallNextObject>Method CallNextObject:T()</td></tr><tr><td style='width:90px'>Description:</td><td>Delegates to ListEnumerator.NextObject().</td></tr><tr><td style='width:90px'>Returns:</td><td>T</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=636New><td class='subtablehead' colspan='2' id=New>Method New(en:ListEnumerator&lt;T&gt;, pred:IPredicate&lt;T&gt;=Null)</td></tr><tr><td style='width:90px'>Description:</td><td>Constructor to wrap a ListEnumerator<T> with an optional IPredicate<T>.</td></tr></table></tr></td></table><br /><table style='width: 100%' id=547WrappedMapValueEnumerable><tr id=WrappedMapValueEnumerable><td class='tablehead' colspan='2'>Class WrappedMapValueEnumerable&lt;K,V&gt; Implements IEnumerable&lt;V&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Wraps Map and the ObjectEnumerator() method to provide access to a PredicateEnumerator&lt;T&gt;.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#556New'>New</a> <i>( Method New(m:Map&lt;K,V&gt;, pred:IPredicate&lt;V&gt;=Null) ) </i> </li><li><a href='#564ObjectEnumerator'>ObjectEnumerator</a> <i>( Method ObjectEnumerator:IEnumerator&lt;V&gt;() ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=556New><td class='subtablehead' colspan='2' id=New>Method New(m:Map&lt;K,V&gt;, pred:IPredicate&lt;V&gt;=Null)</td></tr><tr><td style='width:90px'>Description:</td><td>Constructor to wrap a Map<K,V> enumerator as an IEnumerable<V> with an optional IPredicate<V>.</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=564ObjectEnumerator><td class='subtablehead' colspan='2' id=ObjectEnumerator>Method ObjectEnumerator:IEnumerator&lt;V&gt;()</td></tr><tr><td style='width:90px'>Description:</td><td>Returns a WrappedMapValueEnumerator with the optional predicate.</td></tr><tr><td style='width:90px'>Returns:</td><td>IEnumerator</td></tr></table></tr></td></table><br /><table style='width: 100%' id=516WrappedMapValueEnumerator><tr id=WrappedMapValueEnumerator><td class='tablehead' colspan='2'>Class WrappedMapValueEnumerator&lt;T&gt; Extends PredicateEnumerator&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Extends PredicateEnumerator&lt;T&gt; to wrap MapValueEnumerator&lt;String,T&gt; as an IEnumerator&lt;T&gt;.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#539CallHasNext'>CallHasNext</a> <i>( Method CallHasNext:Bool() ) </i> </li><li><a href='#532CallNextObject'>CallNextObject</a> <i>( Method CallNextObject:T() ) </i> </li><li><a href='#524New'>New</a> <i>( Method New(en:MapValueEnumerator&lt;String,T&gt;, pred:IPredicate&lt;T&gt;=Null) ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=539CallHasNext><td class='subtablehead' colspan='2' id=CallHasNext>Method CallHasNext:Bool()</td></tr><tr><td style='width:90px'>Description:</td><td>Delegates to MapValueEnumerator.HasNext().</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=532CallNextObject><td class='subtablehead' colspan='2' id=CallNextObject>Method CallNextObject:T()</td></tr><tr><td style='width:90px'>Description:</td><td>Delegates to MapValueEnumerator.NextObject().</td></tr><tr><td style='width:90px'>Returns:</td><td>T</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=524New><td class='subtablehead' colspan='2' id=New>Method New(en:MapValueEnumerator&lt;String,T&gt;, pred:IPredicate&lt;T&gt;=Null)</td></tr><tr><td style='width:90px'>Description:</td><td>Constructor to wrap a MapValueEnumerator<String,T> with an optional IPredicate<T>.</td></tr></table></tr></td></table><br /><table style='width: 100%' id=715WrappedSetEnumerable><tr id=WrappedSetEnumerable><td class='tablehead' colspan='2'>Class WrappedSetEnumerable&lt;T&gt; Implements IEnumerable&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Wraps Set and the ObjectEnumerator() method to provide access to a PredicateEnumerator&lt;T&gt;.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#724New'>New</a> <i>( Method New(s:Set&lt;T&gt;, pred:IPredicate&lt;T&gt;) ) </i> </li><li><a href='#732ObjectEnumerator'>ObjectEnumerator</a> <i>( Method ObjectEnumerator:IEnumerator&lt;T&gt;() ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=724New><td class='subtablehead' colspan='2' id=New>Method New(s:Set&lt;T&gt;, pred:IPredicate&lt;T&gt;)</td></tr><tr><td style='width:90px'>Description:</td><td>Constructor to wrap a Set<T> enumerator as an IEnumerable<T> with an optional IPredicate<T>.</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=732ObjectEnumerator><td class='subtablehead' colspan='2' id=ObjectEnumerator>Method ObjectEnumerator:IEnumerator&lt;T&gt;()</td></tr><tr><td style='width:90px'>Description:</td><td>Returns a WrappedSetEnumerator with the optional predicate.</td></tr><tr><td style='width:90px'>Returns:</td><td>IEnumerator</td></tr></table></tr></td></table><br /><table style='width: 100%' id=684WrappedSetEnumerator><tr id=WrappedSetEnumerator><td class='tablehead' colspan='2'>Class WrappedSetEnumerator&lt;T&gt; Extends PredicateEnumerator&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Extends PredicateEnumerator&lt;T&gt; to wrap MapKeyEnumerator&lt;T,Object&gt; as an IEnumerator&lt;T&gt;.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#707CallHasNext'>CallHasNext</a> <i>( Method CallHasNext:Bool() ) </i> </li><li><a href='#700CallNextObject'>CallNextObject</a> <i>( Method CallNextObject:T() ) </i> </li><li><a href='#692New'>New</a> <i>( Method New(en:MapKeyEnumerator&lt;T,Object&gt;, pred:IPredicate&lt;T&gt;=Null) ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=707CallHasNext><td class='subtablehead' colspan='2' id=CallHasNext>Method CallHasNext:Bool()</td></tr><tr><td style='width:90px'>Description:</td><td>Delegates to MapKeyEnumerator.HasNext().</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=700CallNextObject><td class='subtablehead' colspan='2' id=CallNextObject>Method CallNextObject:T()</td></tr><tr><td style='width:90px'>Description:</td><td>Delegates to MapKeyEnumerator.NextObject().</td></tr><tr><td style='width:90px'>Returns:</td><td>T</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=692New><td class='subtablehead' colspan='2' id=New>Method New(en:MapKeyEnumerator&lt;T,Object&gt;, pred:IPredicate&lt;T&gt;=Null)</td></tr><tr><td style='width:90px'>Description:</td><td>Constructor to wrap a MapKeyEnumerator<T,Object> with an optional IPredicate<T>.</td></tr></table></tr></td></table><br /><table style='width: 100%' id=603WrappedStackEnumerable><tr id=WrappedStackEnumerable><td class='tablehead' colspan='2'>Class WrappedStackEnumerable&lt;T&gt; Implements IEnumerable&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Wraps Stack and the ObjectEnumerator() method to provide access to a PredicateEnumerator&lt;T&gt;.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#612New'>New</a> <i>( Method New(s:Stack&lt;T&gt;, pred:IPredicate&lt;T&gt;=Null) ) </i> </li><li><a href='#620ObjectEnumerator'>ObjectEnumerator</a> <i>( Method ObjectEnumerator:IEnumerator&lt;T&gt;() ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=612New><td class='subtablehead' colspan='2' id=New>Method New(s:Stack&lt;T&gt;, pred:IPredicate&lt;T&gt;=Null)</td></tr><tr><td style='width:90px'>Description:</td><td>Constructor to wrap a Stack<T> enumerator as an IEnumerable<T> with an optional IPredicate<T>.</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=620ObjectEnumerator><td class='subtablehead' colspan='2' id=ObjectEnumerator>Method ObjectEnumerator:IEnumerator&lt;T&gt;()</td></tr><tr><td style='width:90px'>Description:</td><td>Returns a WrappedStackEnumerator with the optional predicate.</td></tr><tr><td style='width:90px'>Returns:</td><td>IEnumerator</td></tr></table></tr></td></table><br /><table style='width: 100%' id=572WrappedStackEnumerator><tr id=WrappedStackEnumerator><td class='tablehead' colspan='2'>Class WrappedStackEnumerator&lt;T&gt; Extends PredicateEnumerator&lt;T&gt; </td></tr><tr><td style='width:90px'>Description:</td><td>Extends PredicateEnumerator&lt;T&gt; to wrap StackEnumerator&lt;T&gt; as an IEnumerator&lt;T&gt;.</td></tr><tr><td style='width:90px'>Table of contents:</td><td>Methods:<br><ul><li><a href='#595CallHasNext'>CallHasNext</a> <i>( Method CallHasNext:Bool() ) </i> </li><li><a href='#588CallNextObject'>CallNextObject</a> <i>( Method CallNextObject:T() ) </i> </li><li><a href='#580New'>New</a> <i>( Method New(en:StackEnumerator&lt;T&gt;, pred:IPredicate&lt;T&gt;=Null) ) </i> </li></ul></td></tr><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=595CallHasNext><td class='subtablehead' colspan='2' id=CallHasNext>Method CallHasNext:Bool()</td></tr><tr><td style='width:90px'>Description:</td><td>Delegates to StackEnumerator.HasNext().</td></tr><tr><td style='width:90px'>Returns:</td><td>Bool</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=588CallNextObject><td class='subtablehead' colspan='2' id=CallNextObject>Method CallNextObject:T()</td></tr><tr><td style='width:90px'>Description:</td><td>Delegates to StackEnumerator.NextObject().</td></tr><tr><td style='width:90px'>Returns:</td><td>T</td></tr></table></tr></td><tr><td colspan='2'><table style='width: 100%' class = 'subtable'><tr id=580New><td class='subtablehead' colspan='2' id=New>Method New(en:StackEnumerator&lt;T&gt;, pred:IPredicate&lt;T&gt;=Null)</td></tr><tr><td style='width:90px'>Description:</td><td>Constructor to wrap a StackEnumerator<T> with an optional IPredicate<T>.</td></tr></table></tr></td></table><br />
<p class="junglefooter">This document was generated using the <a href="http://www.jungleide.com/">Jungle IDE</a> document generator version 14.02.11-A</p>
</body>
</html>
